#ifndef  CLUTIL_COMMANDQUEUE_HPP
#define  CLUTIL_COMMANDQUEUE_HPP
/* 						Titles														Authors 												Date
 *-Support command queue (Interface send/receive with vector<shared_ptr<platdevices_info> >
 * 																						  Chatsiri.rat										07/09/2012
 *-Add input_str(Experimental with std::string). input_str is private variable
 * ( not plan include in struct name platdevices_info.
 * 																							Chatsiri.rat										09/09/2012
 *-Add  memory buffer input & output member function.
 * 																							Chatsiri.rat	                  11/09/2012
 */
#include <iostream>
#include "base_clutil.hpp"
#include "clutil_infodevice.hpp"

namespace hnmav_util
{
    using namespace boost;

    class commandqueue : public base_clutil
    {
        public:

            commandqueue(std::size_t buffer_elements_) : buffer_elements(buffer_elements_) { }

            bool cl_create_command_queue();
            bool cl_write_event();
            bool cl_call_kernel();
            bool cl_read_buffer();

            bool cl_enqueue_task();
            bool cl_enqueue_copy_buffer();
            bool cl_enqueue_map_buffer();
            bool cl_enqueue_unmap_buffer();

            bool add_input_str(std::string input_str);


            // Interface class
            std::vector<shared_ptr<platdevices_info> >&    get_platdevices_info_vec() {
                return platdevices_shared_ptr;
            }
            void set_platdevices_info_vec(std::vector<shared_ptr<platdevices_info> >& ptr_info) {
                platdevices_shared_ptr = ptr_info;
            }

            platdevices_info *get_platdevices_data() {
                shared_ptr<platdevices_info>   plat_shared_ptr =  platdevices_shared_ptr.back();
                platdevices_info *platdevices =  plat_shared_ptr.get();
                return platdevices;
            }

        private:

            std::size_t buffer_elements;
            std::vector<shared_ptr<platdevices_info> >  platdevices_shared_ptr;
            // cl define
            platdevices_info *platdevices;
            void   *mapped_memory;
    };


    bool commandqueue::cl_enqueue_unmap_buffer()
    {
        std::cout<< "Start Unmap buffer " << std::endl;
        platdevices_info *platdevices = get_platdevices_data();
        cl_int err = CL_SUCCESS;

        try {
            err = clEnqueueUnmapMemObject(platdevices->queues.back(),
                    platdevices->mem_copy_buffers->back(),
                    mapped_memory,
                    0,
                    NULL,
                    NULL);

            if(err != CL_SUCCESS)
                throw clutil_exception(err, "clEnqueueUnMemObject");

            std::cout<< "### Unmap memory complete ###" <<std::endl;
        } catch(std::runtime_error ex) {
            std::cout<< ex.what() <<std::endl;
        }

    }

    bool commandqueue::cl_enqueue_map_buffer()
    {
        std::cout<< "Start enqueue map buffer " <<std::endl;
        platdevices_info *platdevices =  get_platdevices_data();

        try {
            cl_int err = CL_SUCCESS;
            std::cout<< "Buffer input = " << platdevices->input_str.size() << std::endl;
            std::cout<< "Mem copy check size : " << (sizeof(cl_char) * platdevices->buffer_elements  * platdevices->num_devices)
                    << ", Queue size = "<< platdevices->queues.back() <<std::endl;


            mapped_memory  =  clEnqueueMapBuffer(platdevices->queues.back(),
                    platdevices->mem_copy_buffers->back(),
                    CL_TRUE,
                    CL_MAP_READ,
                    0,
                    sizeof(cl_char) * platdevices->buffer_elements  * platdevices->num_devices,
                    0,
                    NULL,
                    NULL,
                    &err);

            if(err != CL_SUCCESS)
                throw clutil_exception(err, "clEnqueueMapBuffer");

            std::cout<< "### Map memory complete ###" <<std::endl;

					  char  mem_result[platdevices->buffer_elements];
						memcpy(mem_result, mapped_memory,  platdevices->buffer_elements);
						std::cout<< "Data output map = " << mem_result <<std::endl;

        } catch(std::runtime_error ex) {
            std::cout<< ex.what() <<std::endl;
        }

    }

    bool commandqueue::cl_enqueue_copy_buffer()
    {
        std::cout<< "Start enqueue copy buffer " <<std::endl;
        cl_int err = CL_SUCCESS;
        platdevices_info *platdevices = get_platdevices_data();

        try {
            err = clEnqueueCopyBuffer(platdevices->queues.back(),
                    platdevices->mem_input_buffers->back(),
                    platdevices->mem_copy_buffers->back(),
                    0,
                    0,
                    sizeof(cl_char) * platdevices->buffer_elements * platdevices->num_devices,
                    0,
                    NULL,
                    NULL);

            if(err != CL_SUCCESS)
                throw clutil_exception(err, "clEnqueueCopyBuffer");

        } catch(std::runtime_error  ex) {
            std::cout<< ex.what() <<std::endl;
            return false;
        }

        return true;
    }

    bool commandqueue::cl_enqueue_task()
    {
        std::cout<< "Start cl_enqueue_task ... " <<std::endl;
        cl_int err = CL_SUCCESS;
        platdevices_info *platdevices = get_platdevices_data();

        try {
            err = clEnqueueTask(platdevices->queues.back(),
                    platdevices->kernels.back(),
                    0,
                    NULL,
                    NULL);

            if(err != CL_SUCCESS)
                throw clutil_exception(err,"clEnqueueTask");

        } catch(std::runtime_error ex) {
            std::cout<< ex.what() <<std::endl;
            return false;
        }

        return true;
    }

    bool commandqueue::cl_create_command_queue()
    {
        std::cout<< "### Start cl_create_command_queue" <<std::endl;
        cl_int err = CL_SUCCESS;
        platdevices_info *platdevices = get_platdevices_data();

        try {

            for(unsigned int count_queue  = 0; count_queue < platdevices->num_devices; count_queue++) {
	
                InfoDevice<cl_device_type>::display(platdevices->device_ids[count_queue],
                        CL_DEVICE_TYPE,
                        "CL_DEVICE_TYPE");


                cl_command_queue command_queue = clCreateCommandQueue(platdevices->context,
                        platdevices->device_ids[count_queue],
                        0,
                        &err);

                if(err != CL_SUCCESS)
                    throw clutil_exception(err, "clCreateCommandQueue");

                std::cout<< "Address of command queue = " << command_queue <<", count_queue = " << count_queue <<std::endl;

                platdevices->queues.push_back(command_queue);

                cl_kernel  kernel = clCreateKernel(platdevices->program,
                        "square",
                        &err);

                if(err != CL_SUCCESS)
                    throw clutil_exception(err, "clCreateKernel");

                std::cout<< "--Create kernel success--" <<std::endl;

                std::cout<< "--Address of mem_input_buffer = "<< platdevices->mem_input_buffers->back() <<std::endl;
                std::cout<< "--Address of mem_output_buffer = "<< platdevices->mem_copy_buffers->back() <<std::endl;

								for(std::vector<cl_mem>::iterator iter = platdevices->mem_input_buffers->begin();
									  	iter != platdevices->mem_input_buffers->end();
											++iter)
								{
                err = clSetKernelArg(kernel,
                        0,
                        sizeof(cl_mem),
                        &(*iter) /* &platdevices->mem_input_buffers->back() /*[count_queue]*/);

                if(err != CL_SUCCESS)
                    throw clutil_exception(err, "clCreateKernelArg");

								}	

                std::cout<< "--Input set completed " <<std::endl;

								for(std::vector<cl_mem>::iterator iter = platdevices->mem_input_buffers->begin();
									  	iter != platdevices->mem_input_buffers->end();
											++iter)
								{
								
                err = clSetKernelArg(kernel,
                        1,
                        sizeof(cl_mem),
                        &platdevices->mem_copy_buffers->back()/*[count_queue]*/);

                if(err != CL_SUCCESS)
                    throw clutil_exception(err, "clCreateKernelArg");

								}


                std::cout<< "--Output set completed " <<std::endl;


                err = clSetKernelArg(kernel,
                        2,
                        sizeof(cl_int),
                        &platdevices->buffer_elements);

                platdevices->kernels.push_back(kernel);

            }

        } catch(std::runtime_error  ex) {
            std::cout<< ex.what() <<std::endl;
            return false;
        }

        return true;
    }
    bool commandqueue::cl_write_event()
    {
        std::cout<< "### Start cl_write_event " <<std::endl;
        cl_int err = CL_SUCCESS;
        platdevices_info *platdevices = get_platdevices_data();

        try {

            if(platdevices->mem_input_buffers->size() == 0)
                return false;

            err =  clEnqueueWriteBuffer(
                    platdevices->queues[0],
                    platdevices->mem_input_buffers->back(),
                    CL_TRUE,
                    0,
                    sizeof(cl_char) * platdevices->buffer_elements * platdevices->num_devices,
                    (void *)platdevices->input_str.c_str(),
                    0,
                    NULL,
                    NULL);


            if(err != CL_SUCCESS)
                throw clutil_exception(err, "clEnqueueWriteBuffer");

        } catch(std::runtime_error ex) {
            std::cout<< ex.what() <<std::endl;
            return false;
        }

        return true;
    }

    bool commandqueue::cl_call_kernel()
    {
        std::cout<<"### Start cl_call_kernel " <<std::endl;
        cl_int err = CL_SUCCESS;
        platdevices_info *platdevices = get_platdevices_data();

        try {
            for(unsigned int count_queue = 0; count_queue < platdevices->queues.size(); count_queue++) {
                std::size_t  g_wi = platdevices->input_str.size();
                cl_event event;
                err = clEnqueueNDRangeKernel(platdevices->queues[count_queue],
                        platdevices->kernels[count_queue],
                        1,
                        NULL,
                        (const std::size_t *)&g_wi,
                        (const std::size_t *)NULL,
                        0,
                        0,
                        &event);

                if(err != CL_SUCCESS)
                    throw clutil_exception(err, "clEnqueueNDRageKernel");

                platdevices->events.push_back(event);
            }

            clWaitForEvents(platdevices->events.size(), const_cast<cl_event *>(&platdevices->events[0]));
        } catch(std::runtime_error  ex) {
            std::cout<< "Error : " << ex.what() <<std::endl;
            return false;
        }

        return true;
    }

    bool commandqueue::cl_read_buffer()
    {
        std::cout<< "Start cl_read_buffer " << std::endl;
        platdevices_info *platdevices = get_platdevices_data();
        clEnqueueReadBuffer(platdevices->queues[0],
                platdevices->mem_input_buffers->back(),
                CL_TRUE,
                0,
                sizeof(cl_char) * platdevices->buffer_elements * platdevices->num_devices,
                (void *)platdevices->input_str.c_str(),
                0,
                NULL,
                NULL);
        return true;
    }

    bool commandqueue::add_input_str(std::string input_str)
    {
        platdevices_info *platdevices = get_platdevices_data();

        if(input_str.size() == 0)
            return false;

        platdevices->input_str = input_str;
        return true;
    }

    class clutil_commandqueue : public base_clutil
    {
        public:
            clutil_commandqueue(std::size_t buffer_elements_) : commandqueue_util(new commandqueue(buffer_elements_)) { }
            bool cl_create_command_queue();
            bool cl_write_event();
            bool cl_call_kernel();
            bool cl_read_buffer();

            bool cl_enqueue_task();
            bool cl_enqueue_copy_buffer();
            bool cl_enqueue_map_buffer();

            bool cl_enqueue_unmap_buffer();

            bool add_input_str(std::string input_str);

            // Interface class
            std::vector<shared_ptr<platdevices_info> >&    get_platdevices_info_vec() {
                return  commandqueue_util->get_platdevices_info_vec();
            }
            void set_platdevices_info_vec(std::vector<shared_ptr<platdevices_info> >& ptr_info) {
                commandqueue_util->set_platdevices_info_vec(ptr_info);
            }

            platdevices_info *get_platdevices_data() {
                return commandqueue_util->get_platdevices_data();
            }

        private:
            commandqueue *commandqueue_util;
    };

    bool clutil_commandqueue::cl_create_command_queue()
    {
        return commandqueue_util->cl_create_command_queue();
    }

    bool clutil_commandqueue::cl_write_event()
    {
        return commandqueue_util->cl_write_event();
    }

    bool clutil_commandqueue::cl_call_kernel()
    {
        return commandqueue_util->cl_call_kernel();
    }

    bool clutil_commandqueue::cl_read_buffer()
    {
        return commandqueue_util->cl_read_buffer();
    }

    bool clutil_commandqueue::add_input_str(std::string input_str)
    {
        return commandqueue_util->add_input_str(input_str);
    }

    bool clutil_commandqueue::cl_enqueue_task()
    {
        return commandqueue_util->cl_enqueue_task();
    }

    bool clutil_commandqueue::cl_enqueue_copy_buffer()
    {
        return  commandqueue_util->cl_enqueue_copy_buffer();
    }

    bool clutil_commandqueue::cl_enqueue_map_buffer()
    {
        return commandqueue_util->cl_enqueue_map_buffer();
    }

    bool clutil_commandqueue::cl_enqueue_unmap_buffer()
    {
        return commandqueue_util->cl_enqueue_unmap_buffer();
    }


}



#endif /* CLUTIL_COMMANDQUEUE_HPP */
