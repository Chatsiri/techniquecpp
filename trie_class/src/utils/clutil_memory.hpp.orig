#ifndef HNMAV_UTIL_CLUTIL_MEMORY_HPP
#define HNMAV_UTIL_CLUTIL_MEMORY__HPP

/* 						Titles														Authors 												Date
 * -Add utility for managment memory 						Chatsiri.rat										26/08/2012
 * -Move utiltity class to PIMP idom 						Chatsiri.rat										27/08/2012
 * -Add interface class													Chatsiri.rat										27/08/2012
 * -API concept using Proxy class	clutil_memory	Chatsiri.rat										01/09/2012
 */

/*3th libraries */
#include <boost/shared_ptr.hpp>
#include <vector>

#include "CL/cl.h"

#include "utils/base_clutil.hpp"
#include "utils/clutil_exception.hpp"

using namespace boost;

namespace hnmav_util
{
    //  memory internal initial, write Real Object here.
    class memory : public base_clutil
    {
        public:

            memory();

            bool  cl_create_buffer(std::string buffer_elements);

            bool  cl_create_subbuffer();

            bool  cl_check_buffer_size();

            // Interface class
            std::vector<shared_ptr<platdevices_info> >&    get_platdevices_info_vec() {
                return platdevices_shared_ptr;
            }
            void set_platdevices_info_vec(std::vector<shared_ptr<platdevices_info> >& ptr_info) {
                platdevices_shared_ptr = ptr_info;
            }

					  platdevices_info * get_platdevices_data(){
        			shared_ptr<platdevices_info>   plat_shared_ptr = platdevices_shared_ptr.back();
        			platdevices_info *platdevices =  plat_shared_ptr.get();
							return platdevices;
						}


        private:

            std::size_t buffer_elements;
            std::vector<shared_ptr<platdevices_info> >  platdevices_shared_ptr;
            // cl define
            platdevices_info *platdevices;

    };

    memory::memory()
    {

    }

    bool memory::cl_create_subbuffer()
    {
				std::cout<< "Start cl_create_subffer " <<std::endl;
        cl_int err = CL_SUCCESS;
        platdevices_info *platdevices = get_platdevices_data();

        try {
            for(int count_devices = 0; count_devices < platdevices->num_devices; count_devices++) {

                cl_buffer_region  region = {
                    buffer_elements *count_devices * sizeof(cl_char), // origin 
                   buffer_elements * sizeof(cl_char) // size 
                };
								
								if(platdevices->mem_input_buffers->size() == 0)							 
									return false; 

                cl_mem buffer =  clCreateSubBuffer(platdevices->mem_input_buffers->back(),
                        CL_MEM_READ_WRITE,
                        CL_BUFFER_CREATE_TYPE_REGION,
                        &region,
                        &err);

                platdevices->mem_input_buffers->push_back(buffer);
            }

            if(err == CL_SUCCESS)
                throw clutil_exception(err, "clCreateSubBuffer");

        } catch(std::runtime_error& ex) {
            std::cout<< "Error : " << ex.what() <<std::endl;
            return false;
        }

        return true;
    }

    bool memory::cl_create_buffer(std::string  buffer_str)
    {
				std::cout<< "Start cl_create_buffer " <<std::endl;
        try {

            cl_int err = CL_SUCCESS;
            platdevices_info *platdevices 	= get_platdevices_data();
						// create buffer input & copy 
					  platdevices->mem_input_buffers 	= new std::vector<cl_mem>();	
					  platdevices->mem_copy_buffers 	= new std::vector<cl_mem>();
			      std::istringstream  input_stream(buffer_str);
						input_stream >> platdevices->ibuffer;

            platdevices->buffer_elements 		=  buffer_str.size();
						platdevices->input_str 			 		=  buffer_str;

						std::cout<< "-- Convert String to float -- " <<std::endl;
						std::cout<< "-- Size of num_devices = " << platdevices->num_devices <<std::endl;
						
            cl_mem buffer_input = clCreateBuffer(platdevices->context,
                    CL_MEM_READ_WRITE | CL_MEM_COPY_HOST_PTR,
                    sizeof(cl_char) * platdevices->buffer_elements * platdevices->num_devices,
                    (void*)platdevices->input_str.c_str(),
                    &err);
	        if(err != CL_SUCCESS)
                throw clutil_exception(err, "clCreateBuffer");
	 					std::cout<<"-- Initial buffer input completed, Address = "<< buffer_input <<std::endl;

			  cl_mem buffer_output =   clCreateBuffer(platdevices->context,
                    CL_MEM_READ_WRITE | CL_MEM_COPY_HOST_PTR,
                    sizeof(cl_char) * platdevices->buffer_elements * platdevices->num_devices,
                    (void*)platdevices->output_str.c_str(),
                    &err);

/*        cl_mem size_input =  clCreateBuffer(platdevices->context,
                    CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR,
                    sizeof(cl_int),
                    &platdevices->buffer_elements,
                    &err);
*/ 


            if(err != CL_SUCCESS)
                throw clutil_exception(err, "clCreateBuffer");
    					std::cout<<"-- Initial buffer output  completed, Address = "<< buffer_output <<std::endl;
         
						platdevices->mem_input_buffers->push_back(buffer_input);
            platdevices->mem_copy_buffers->push_back(buffer_output);

        } catch(std::runtime_error&  ex) {
            std::cout << ex.what() <<std::endl;
            return false;
        }
        return true;
    }

    bool memory::cl_check_buffer_size()
    {
				std::cout<< "Start cl_check buffer size ... " <<std::endl;
        std::size_t buffer_size;
        platdevices_info *platdevices = get_platdevices_data();

        for(std::vector<cl_mem>::iterator iter = platdevices->mem_input_buffers->begin();
                iter != platdevices->mem_input_buffers->end();
                ++iter) {
            clGetMemObjectInfo(*iter,
                    CL_MEM_SIZE,
                    sizeof(cl_char) * platdevices->buffer_elements * platdevices->num_devices,
                    & buffer_elements,
                    NULL);
            std::cout<<"### buffer size = "<<  buffer_size <<std::endl;
        }

        return true;
    }

    // Handeler memory
    class clutil_memory : public base_clutil
    {
        public:
            clutil_memory();

            void cl_create_buffer(std::string buffer_elements);
            bool cl_create_subbuffer();
            bool cl_check_buffer_size();

            ~clutil_memory();

            std::vector<shared_ptr<platdevices_info> >&    get_platdevices_info_vec() {
                return  memory_util->get_platdevices_info_vec();
            }
            void set_platdevices_info_vec(std::vector<shared_ptr<platdevices_info> >& ptr_info) {
                memory_util->set_platdevices_info_vec(ptr_info);
            }
						
						platdevices_info * get_platdevices_data()
						{
								return memory_util->get_platdevices_data();
						}

        private:
            memory *memory_util;

    };

    clutil_memory::clutil_memory() : memory_util(new memory())
    {

    }

    void  clutil_memory::cl_create_buffer(std::string buffer_elements)
    {
        memory_util->cl_create_buffer(buffer_elements);
    }

    bool  clutil_memory::cl_create_subbuffer()
    {
        return	memory_util->cl_create_subbuffer();
    }

    bool clutil_memory::cl_check_buffer_size()
    {
        return memory_util->cl_check_buffer_size();
    }

    clutil_memory::~clutil_memory()
    {

    }



}

#endif /*HNMAV_UTIL_CLUTIL_HPP */
